# Copyright (c) 2020-present, Royal Bank of Canada.
# All rights reserved.
#
# This source code is licensed under the license found in the
# LICENSE file in the root directory of this source tree.
#

################################
# val: number(float)/string(str)/sql(dict)/col_unit
# col_unit: (agg_id, col_id, isDistinct(bool))
# val_unit: (unit_op, col_unit1, col_unit2)
# table_unit: (table_type, col_id/sql)
# cond_unit: (not_op, op_id, val_unit, val1, val2)
# condition: [cond_unit1, 'and'/'or', cond_unit2, ...]
# sql {
#   'select': (isDistinct(bool), [(agg_id, val_unit), (agg_id, val_unit), ...])
#   'from': {'table_units': [table_unit1, table_unit2, ...], 'conds': condition}
#   'where': condition
#   'groupBy': [col_unit1, col_unit2, ...]
#   'orderBy': ('asc'/'desc', [val_unit1, val_unit2, ...])
#   'having': condition
#   'limit': None/limit value
#   'intersect': None/sql
#   'except': None/sql
#   'union': None/sql
# }
################################
import json

CLAUSE_KEYWORDS = ('SELECT', 'FROM', 'WHERE', 'GROUP', 'ORDER', 'LIMIT', 'INTERSECT', 'UNION', 'EXCEPT')
JOIN_KEYWORDS = ('JOIN', 'ON', 'AS')

WHERE_OPS = ('NOT', 'BETWEEN', '=', '>', '<', '>=', '<=', '!=', 'IN', 'LIKE', 'IS', 'EXISTS')
UNIT_OPS = ('none', '-', '+', "*", '/')
AGG_OPS = ('none', 'MAX', 'MIN', 'COUNT', 'SUM', 'AVG')
TABLE_TYPE = {
    'sql': "sql",
    'table_unit': "table_unit",
}

COND_OPS = ('AND', 'OR')
SQL_OPS = ('INTERSECT', 'UNION', 'EXCEPT')
ORDER_OPS = ('DESC', 'ASC')


class SpiderAST():
    def __init__(self,
                 AST: dict,
                 database: dict,
                 gold_sql: str = None,
                 add_alias: bool = False) -> None:
        '''
        AST: This is a dictionary generated by "process_sql.py" from "https://github.com/taoyds/spider"
        and represents an abstract syntax tree.
        database: Contains information about the database taken from "tables.json" in the Spider Dataset.
        '''
        self.spiderAST = AST
        self.add_alias = add_alias
        self._except = AST['except']
        self._from = AST['from']
        self._groupBy = AST['groupBy']
        self._having = AST['having']
        self._intersect = AST['intersect']
        self._limit = AST['limit']
        self._orderBy = AST['orderBy']
        self._select = AST['select']
        self._union = AST['union']
        self._where = AST['where']

        self.gold_sql = gold_sql

        self.database = database
        self.table_names = database['table_names_original']
        self.col_names = database['column_names_original']

        self._sql = []

        if self.add_alias:
            self._get_alias()
        self._parse_select()
        self._parse_from()
        self._parse_where()
        self._parse_groupBy()
        self._parse_orderBy()
        self._parse_limit()
        self._parse_having()
        self._parse_intersect()
        self._parse_union()
        self._parse_except()

    def pretty_print(self) -> None:
        print(json.dumps(self.spiderAST, indent=4))

    def _parse_col_unit_distinct(self, val):
        if val[2]:
            self._sql.append("DISTINCT")
            self._sql.append(" ")

    def _parse_col_unit(self, col_unit):
        # inner aggregation op
        if col_unit[0] != 0:
            self._sql.append(AGG_OPS[col_unit[0]])
            self._sql.append(" ")
            self._sql.append("(")
            self._sql.append(" ")
        self._parse_col_unit_distinct(col_unit)
        # add column name
        col_id = col_unit[1]
        col_name = self.col_names[col_id][1]
        if col_name == "*":
            self._sql.append(col_name)
        else:
            table_id = self.col_names[col_id][0]
            if self.add_alias:
                table_alias = self.alias[table_id]
                self._sql.append(table_alias + "." + col_name)
            else:
                table_name = self.table_names[table_id]
                self._sql.append(table_name + "." + col_name)
        if col_unit[0] != 0:
            self._sql.append(" ")
            self._sql.append(")")

    def _parse_val_unit(self, val_unit):
        if val_unit[0] == 0:
            self._parse_col_unit(val_unit[1])
        else:
            self._parse_col_unit(val_unit[1])
            self._sql.append(" ")
            self._sql.append(UNIT_OPS[val_unit[0]])
            self._sql.append(" ")
            self._parse_col_unit(val_unit[2])

    def _parse_column(self):
        for i in range(len(self._select[1])):
            col = self._select[1][i]
            if i > 0:
                self._sql.append(" ")
                self._sql.append(",")
            self._sql.append(" ")
            # outer aggregation op
            if col[0] != 0:
                self._sql.append(AGG_OPS[col[0]])
                self._sql.append(" ")
                self._sql.append("(")
                self._sql.append(" ")
            self._parse_val_unit(col[1])
            if col[0] != 0:
                self._sql.append(" ")
                self._sql.append(")")

    def _parse_select_distinct(self):
        if self._select[0]:
            self._sql.append(" ")
            self._sql.append("DISTINCT")

    def _parse_select(self):
        self._sql.append("SELECT")
        self._parse_select_distinct()
        self._parse_column()

    def _get_alias(self):
        self.alias = {}
        count = {}
        for i in range(len(self._from['table_units'])):
            item = self._from['table_units'][i]
            table_id = item[1]
            if item[0] == 'sql':
                continue
            count[table_id] = 0
        for i in range(len(self._from['table_units'])):
            item = self._from['table_units'][i]
            if item[0] == 'sql':
                continue
            table_id = item[1]
            table_name = self.table_names[table_id]
            table_alias = table_name + '_' + str(count[table_id])
            count[table_id] += 1
            self.alias[table_id] = table_alias

    def _parse_on(self):
        if len(self._from['conds']) > 0:
            self._sql.append(" ")
            self._sql.append("ON")
        for i in range(len(self._from['conds'])):
            cond_unit = self._from['conds'][i]
            self._sql.append(" ")
            if isinstance(cond_unit, str):
                self._sql.append(cond_unit)
                self._sql.append(" ")
            else:
                self._parse_cond_unit(cond_unit)

    def _parse_from(self):
        self._sql.append(" ")
        self._sql.append("FROM")
        for i in range(len(self._from['table_units'])):
            table_type = self._from['table_units'][i][0]
            table = self._from['table_units'][i][1]
            if i > 0:
                self._sql.append(" ")
                self._sql.append("JOIN")
            self._sql.append(" ")
            if table_type == 'table_unit':
                table_name = self.table_names[table]
                self._sql.append(table_name)
                if self.add_alias:
                    self._sql.append(" ")
                    self._sql.append("AS")
                    self._sql.append(" ")
                    self._sql.append(self.alias[table])
            else:  # from (select ...)
                self._sql.append("(")
                self._sql.append(" ")
                nested_AST = SpiderAST(table, self.database)
                nested_sql = nested_AST.get_sql()
                self._sql.append(nested_sql)
                self._sql.append(" ")
                self._sql.append(")")
                self._sql.append(" ")
        self._parse_on()

    def _parse_cond_unit_val(self, cond_unit_val):
        if isinstance(cond_unit_val, int) or isinstance(cond_unit_val, float):
            self._sql.append(str(cond_unit_val))
        elif (isinstance(cond_unit_val, list) or isinstance(cond_unit_val, tuple)) \
            and all(isinstance(item, str) for item in cond_unit_val):
            self._sql.append(self._prepare_value_list(cond_unit_val))
        elif isinstance(cond_unit_val, str):
            self._sql.append(cond_unit_val)
        elif isinstance(cond_unit_val, dict):
            self._sql.append("(")
            self._sql.append(" ")
            nested_AST = SpiderAST(cond_unit_val, self.database)
            nested_sql = nested_AST.get_sql()
            self._sql.append(nested_sql)
            self._sql.append(" ")
            self._sql.append(")")
        else:
            self._parse_col_unit(cond_unit_val)

    def _prepare_value_list(self, val):
        return "( " + " , ".join(val) + " )"

    def _parse_not(self, val):
        if val:
            self._sql.append(" ")
            self._sql.append("NOT")

    def _parse_cond_unit(self, cond_unit):
        self._sql.append(" ")
        self._parse_val_unit(cond_unit[2])
        self._parse_not(cond_unit[0])
        # add where ops
        self._sql.append(" ")
        self._sql.append(WHERE_OPS[cond_unit[1]])
        self._sql.append(" ")
        self._parse_cond_unit_val(cond_unit[3])
        if cond_unit[4] is not None:
            self._sql.append(" ")
            self._sql.append("AND")
            self._sql.append(" ")
            self._parse_cond_unit_val(cond_unit[4])

    def _parse_where(self):
        if len(self._where) > 0:
            self._sql.append(" ")
            self._sql.append("WHERE")
        for i in range(len(self._where)):
            cond_unit = self._where[i]
            if isinstance(cond_unit, str):
                self._sql.append(" ")
                self._sql.append(cond_unit)
            else:
                self._parse_cond_unit(cond_unit)

    def _parse_orderBy(self):
        if len(self._orderBy) > 0:
            self._sql.append(" ")
            self._sql.append("ORDER BY")
            for i in range(len(self._orderBy[1])):
                if i > 0:
                    self._sql.append(" ")
                    self._sql.append(",")
                self._sql.append(" ")
                col = self._orderBy[1][i]
                self._parse_val_unit(col)
            if self._orderBy[0] == "desc":
                self._sql.append(" ")
                self._sql.append("DESC")

    def _parse_limit(self):
        if self._limit is not None:
            self._sql.append(" ")
            self._sql.append("LIMIT")
            self._sql.append(" ")
            self._sql.append(str(self._limit))

    def _parse_groupBy(self):
        if len(self._groupBy) > 0:
            self._sql.append(" ")
            self._sql.append("GROUP BY")
        for i in range(len(self._groupBy)):
            col = self._groupBy[i]
            self._sql.append(" ")
            if i > 0:
                self._sql.append(",")
                self._sql.append(" ")
            self._parse_col_unit(col)

    def _parse_having(self):
        if len(self._having) > 0:
            self._sql.append(" ")
            self._sql.append("HAVING")
        for i in range(len(self._having)):
            cond_unit = self._having[i]
            if isinstance(cond_unit, str):
                self._sql.append(" ")
                self._sql.append(cond_unit)
            else:
                self._parse_cond_unit(cond_unit)

    def _parse_intersect(self):
        if self._intersect is not None:
            self._sql.append(" ")
            self._sql.append("INTERSECT")
            self._sql.append(" ")
            nested_AST = SpiderAST(self._intersect, self.database)
            nested_sql = nested_AST.get_sql()
            self._sql.append(nested_sql)

    def _parse_union(self):
        if self._union is not None:
            self._sql.append(" ")
            self._sql.append("UNION")
            self._sql.append(" ")
            nested_AST = SpiderAST(self._union, self.database)
            nested_sql = nested_AST.get_sql()
            self._sql.append(nested_sql)

    def _parse_except(self):
        if self._except is not None:
            self._sql.append(" ")
            self._sql.append("EXCEPT")
            self._sql.append(" ")
            nested_AST = SpiderAST(self._except, self.database)
            nested_sql = nested_AST.get_sql()
            self._sql.append(nested_sql)

    def get_sql(self) -> str:
        return "".join(self._sql)
